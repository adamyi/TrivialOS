/* This is based on RFC3530 which contains the following copyright statement:


   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
*/
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "libnfs-zdr.h"
#include "libnfs-raw-nfs4.h"

uint32_t
zdr_nfs_ftype4 (ZDR *zdrs, nfs_ftype4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfsstat4 (ZDR *zdrs, nfsstat4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_bitmap4 (ZDR *zdrs, bitmap4 *objp)
{
	

	 if (!zdr_array (zdrs, (char **)&objp->bitmap4_val, (u_int *) &objp->bitmap4_len, ~0,
		sizeof (uint32_t), (zdrproc_t) zdr_uint32_t))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_offset4 (ZDR *zdrs, offset4 *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_count4 (ZDR *zdrs, count4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_length4 (ZDR *zdrs, length4 *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_clientid4 (ZDR *zdrs, clientid4 *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_seqid4 (ZDR *zdrs, seqid4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_utf8string (ZDR *zdrs, utf8string *objp)
{
	

	 if (!zdr_bytes (zdrs, (char **)&objp->utf8string_val, (u_int *) &objp->utf8string_len, ~0))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_utf8str_cis (ZDR *zdrs, utf8str_cis *objp)
{
	

	 if (!zdr_utf8string (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_utf8str_cs (ZDR *zdrs, utf8str_cs *objp)
{
	

	 if (!zdr_utf8string (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_utf8str_mixed (ZDR *zdrs, utf8str_mixed *objp)
{
	

	 if (!zdr_utf8string (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_component4 (ZDR *zdrs, component4 *objp)
{
	

	 if (!zdr_utf8str_cs (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_pathname4 (ZDR *zdrs, pathname4 *objp)
{
	

	 if (!zdr_array (zdrs, (char **)&objp->pathname4_val, (u_int *) &objp->pathname4_len, ~0,
		sizeof (component4), (zdrproc_t) zdr_component4))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_lockid4 (ZDR *zdrs, nfs_lockid4 *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_cookie4 (ZDR *zdrs, nfs_cookie4 *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_linktext4 (ZDR *zdrs, linktext4 *objp)
{
	

	 if (!zdr_utf8str_cs (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_sec_oid4 (ZDR *zdrs, sec_oid4 *objp)
{
	

	 if (!zdr_bytes (zdrs, (char **)&objp->sec_oid4_val, (u_int *) &objp->sec_oid4_len, ~0))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_qop4 (ZDR *zdrs, qop4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_mode4 (ZDR *zdrs, mode4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_changeid4 (ZDR *zdrs, changeid4 *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_verifier4 (ZDR *zdrs, verifier4 objp)
{
	

	 if (!zdr_opaque (zdrs, objp, NFS4_VERIFIER_SIZE))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfstime4 (ZDR *zdrs, nfstime4 *objp)
{
	

	 if (!zdr_int64_t (zdrs, &objp->seconds))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->nseconds))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_time_how4 (ZDR *zdrs, time_how4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_settime4 (ZDR *zdrs, settime4 *objp)
{
	

	 if (!zdr_time_how4 (zdrs, &objp->set_it))
		 return FALSE;
	switch (objp->set_it) {
	case SET_TO_CLIENT_TIME4:
		 if (!zdr_nfstime4 (zdrs, &objp->settime4_u.time))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_nfs_fh4 (ZDR *zdrs, nfs_fh4 *objp)
{
	

	 if (!zdr_bytes (zdrs, (char **)&objp->nfs_fh4_val, (u_int *) &objp->nfs_fh4_len, NFS4_FHSIZE))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fsid4 (ZDR *zdrs, fsid4 *objp)
{
	

	 if (!zdr_uint64_t (zdrs, &objp->major))
		 return FALSE;
	 if (!zdr_uint64_t (zdrs, &objp->minor))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fs_location4 (ZDR *zdrs, fs_location4 *objp)
{
	

	 if (!zdr_array (zdrs, (char **)&objp->server.server_val, (u_int *) &objp->server.server_len, ~0,
		sizeof (utf8str_cis), (zdrproc_t) zdr_utf8str_cis))
		 return FALSE;
	 if (!zdr_pathname4 (zdrs, &objp->rootpath))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fs_locations4 (ZDR *zdrs, fs_locations4 *objp)
{
	

	 if (!zdr_pathname4 (zdrs, &objp->fs_root))
		 return FALSE;
	 if (!zdr_array (zdrs, (char **)&objp->locations.locations_val, (u_int *) &objp->locations.locations_len, ~0,
		sizeof (fs_location4), (zdrproc_t) zdr_fs_location4))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_acetype4 (ZDR *zdrs, acetype4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_aceflag4 (ZDR *zdrs, aceflag4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_acemask4 (ZDR *zdrs, acemask4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfsace4 (ZDR *zdrs, nfsace4 *objp)
{
	

	 if (!zdr_acetype4 (zdrs, &objp->type))
		 return FALSE;
	 if (!zdr_aceflag4 (zdrs, &objp->flag))
		 return FALSE;
	 if (!zdr_acemask4 (zdrs, &objp->access_mask))
		 return FALSE;
	 if (!zdr_utf8str_mixed (zdrs, &objp->who))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_specdata4 (ZDR *zdrs, specdata4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, &objp->specdata1))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->specdata2))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_supported_attrs (ZDR *zdrs, fattr4_supported_attrs *objp)
{
	

	 if (!zdr_bitmap4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_type (ZDR *zdrs, fattr4_type *objp)
{
	

	 if (!zdr_nfs_ftype4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_fh_expire_type (ZDR *zdrs, fattr4_fh_expire_type *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_change (ZDR *zdrs, fattr4_change *objp)
{
	

	 if (!zdr_changeid4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_size (ZDR *zdrs, fattr4_size *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_link_support (ZDR *zdrs, fattr4_link_support *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_symlink_support (ZDR *zdrs, fattr4_symlink_support *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_named_attr (ZDR *zdrs, fattr4_named_attr *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_fsid (ZDR *zdrs, fattr4_fsid *objp)
{
	

	 if (!zdr_fsid4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_unique_handles (ZDR *zdrs, fattr4_unique_handles *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_lease_time (ZDR *zdrs, fattr4_lease_time *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_rdattr_error (ZDR *zdrs, fattr4_rdattr_error *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_acl (ZDR *zdrs, fattr4_acl *objp)
{
	

	 if (!zdr_array (zdrs, (char **)&objp->fattr4_acl_val, (u_int *) &objp->fattr4_acl_len, ~0,
		sizeof (nfsace4), (zdrproc_t) zdr_nfsace4))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_aclsupport (ZDR *zdrs, fattr4_aclsupport *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_archive (ZDR *zdrs, fattr4_archive *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_cansettime (ZDR *zdrs, fattr4_cansettime *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_case_insensitive (ZDR *zdrs, fattr4_case_insensitive *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_case_preserving (ZDR *zdrs, fattr4_case_preserving *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_chown_restricted (ZDR *zdrs, fattr4_chown_restricted *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_fileid (ZDR *zdrs, fattr4_fileid *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_files_avail (ZDR *zdrs, fattr4_files_avail *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_filehandle (ZDR *zdrs, fattr4_filehandle *objp)
{
	

	 if (!zdr_nfs_fh4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_files_free (ZDR *zdrs, fattr4_files_free *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_files_total (ZDR *zdrs, fattr4_files_total *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_fs_locations (ZDR *zdrs, fattr4_fs_locations *objp)
{
	

	 if (!zdr_fs_locations4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_hidden (ZDR *zdrs, fattr4_hidden *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_homogeneous (ZDR *zdrs, fattr4_homogeneous *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_maxfilesize (ZDR *zdrs, fattr4_maxfilesize *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_maxlink (ZDR *zdrs, fattr4_maxlink *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_maxname (ZDR *zdrs, fattr4_maxname *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_maxread (ZDR *zdrs, fattr4_maxread *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_maxwrite (ZDR *zdrs, fattr4_maxwrite *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_mimetype (ZDR *zdrs, fattr4_mimetype *objp)
{
	

	 if (!zdr_utf8str_cs (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_mode (ZDR *zdrs, fattr4_mode *objp)
{
	

	 if (!zdr_mode4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_mounted_on_fileid (ZDR *zdrs, fattr4_mounted_on_fileid *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_no_trunc (ZDR *zdrs, fattr4_no_trunc *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_numlinks (ZDR *zdrs, fattr4_numlinks *objp)
{
	

	 if (!zdr_uint32_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_owner (ZDR *zdrs, fattr4_owner *objp)
{
	

	 if (!zdr_utf8str_mixed (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_owner_group (ZDR *zdrs, fattr4_owner_group *objp)
{
	

	 if (!zdr_utf8str_mixed (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_quota_avail_hard (ZDR *zdrs, fattr4_quota_avail_hard *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_quota_avail_soft (ZDR *zdrs, fattr4_quota_avail_soft *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_quota_used (ZDR *zdrs, fattr4_quota_used *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_rawdev (ZDR *zdrs, fattr4_rawdev *objp)
{
	

	 if (!zdr_specdata4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_space_avail (ZDR *zdrs, fattr4_space_avail *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_space_free (ZDR *zdrs, fattr4_space_free *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_space_total (ZDR *zdrs, fattr4_space_total *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_space_used (ZDR *zdrs, fattr4_space_used *objp)
{
	

	 if (!zdr_uint64_t (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_system (ZDR *zdrs, fattr4_system *objp)
{
	

	 if (!zdr_bool (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_time_access (ZDR *zdrs, fattr4_time_access *objp)
{
	

	 if (!zdr_nfstime4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_time_access_set (ZDR *zdrs, fattr4_time_access_set *objp)
{
	

	 if (!zdr_settime4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_time_backup (ZDR *zdrs, fattr4_time_backup *objp)
{
	

	 if (!zdr_nfstime4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_time_create (ZDR *zdrs, fattr4_time_create *objp)
{
	

	 if (!zdr_nfstime4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_time_delta (ZDR *zdrs, fattr4_time_delta *objp)
{
	

	 if (!zdr_nfstime4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_time_metadata (ZDR *zdrs, fattr4_time_metadata *objp)
{
	

	 if (!zdr_nfstime4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_time_modify (ZDR *zdrs, fattr4_time_modify *objp)
{
	

	 if (!zdr_nfstime4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4_time_modify_set (ZDR *zdrs, fattr4_time_modify_set *objp)
{
	

	 if (!zdr_settime4 (zdrs, objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_attrlist4 (ZDR *zdrs, attrlist4 *objp)
{
	

	 if (!zdr_bytes (zdrs, (char **)&objp->attrlist4_val, (u_int *) &objp->attrlist4_len, ~0))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_fattr4 (ZDR *zdrs, fattr4 *objp)
{
	

	 if (!zdr_bitmap4 (zdrs, &objp->attrmask))
		 return FALSE;
	 if (!zdr_attrlist4 (zdrs, &objp->attr_vals))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_change_info4 (ZDR *zdrs, change_info4 *objp)
{
	

	 if (!zdr_bool (zdrs, &objp->atomic))
		 return FALSE;
	 if (!zdr_changeid4 (zdrs, &objp->before))
		 return FALSE;
	 if (!zdr_changeid4 (zdrs, &objp->after))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_clientaddr4 (ZDR *zdrs, clientaddr4 *objp)
{
	

	 if (!zdr_string (zdrs, &objp->r_netid, ~0))
		 return FALSE;
	 if (!zdr_string (zdrs, &objp->r_addr, ~0))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_cb_client4 (ZDR *zdrs, cb_client4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, &objp->cb_program))
		 return FALSE;
	 if (!zdr_clientaddr4 (zdrs, &objp->cb_location))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_stateid4 (ZDR *zdrs, stateid4 *objp)
{
	

	
	 if (!zdr_uint32_t (zdrs, &objp->seqid))
		 return FALSE;
	 if (!zdr_opaque (zdrs, objp->other, 12))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_client_id4 (ZDR *zdrs, nfs_client_id4 *objp)
{
	

	 if (!zdr_verifier4 (zdrs, objp->verifier))
		 return FALSE;
	 if (!zdr_bytes (zdrs, (char **)&objp->id.id_val, (u_int *) &objp->id.id_len, NFS4_OPAQUE_LIMIT))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_open_owner4 (ZDR *zdrs, open_owner4 *objp)
{
	

	 if (!zdr_clientid4 (zdrs, &objp->clientid))
		 return FALSE;
	 if (!zdr_bytes (zdrs, (char **)&objp->owner.owner_val, (u_int *) &objp->owner.owner_len, NFS4_OPAQUE_LIMIT))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_lock_owner4 (ZDR *zdrs, lock_owner4 *objp)
{
	

	 if (!zdr_clientid4 (zdrs, &objp->clientid))
		 return FALSE;
	 if (!zdr_bytes (zdrs, (char **)&objp->owner.owner_val, (u_int *) &objp->owner.owner_len, NFS4_OPAQUE_LIMIT))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_lock_type4 (ZDR *zdrs, nfs_lock_type4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_ACCESS4args (ZDR *zdrs, ACCESS4args *objp)
{
	

	 if (!zdr_uint32_t (zdrs, &objp->access))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_ACCESS4resok (ZDR *zdrs, ACCESS4resok *objp)
{
	

	 if (!zdr_uint32_t (zdrs, &objp->supported))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->access))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_ACCESS4res (ZDR *zdrs, ACCESS4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_ACCESS4resok (zdrs, &objp->ACCESS4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_CLOSE4args (ZDR *zdrs, CLOSE4args *objp)
{
	

	 if (!zdr_seqid4 (zdrs, &objp->seqid))
		 return FALSE;
	 if (!zdr_stateid4 (zdrs, &objp->open_stateid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CLOSE4res (ZDR *zdrs, CLOSE4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_stateid4 (zdrs, &objp->CLOSE4res_u.open_stateid))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_COMMIT4args (ZDR *zdrs, COMMIT4args *objp)
{
	

	 if (!zdr_offset4 (zdrs, &objp->offset))
		 return FALSE;
	 if (!zdr_count4 (zdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_COMMIT4resok (ZDR *zdrs, COMMIT4resok *objp)
{
	

	 if (!zdr_verifier4 (zdrs, objp->writeverf))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_COMMIT4res (ZDR *zdrs, COMMIT4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_COMMIT4resok (zdrs, &objp->COMMIT4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_createtype4 (ZDR *zdrs, createtype4 *objp)
{
	

	 if (!zdr_nfs_ftype4 (zdrs, &objp->type))
		 return FALSE;
	switch (objp->type) {
	case NF4LNK:
		 if (!zdr_linktext4 (zdrs, &objp->createtype4_u.linkdata))
			 return FALSE;
		break;
	case NF4BLK:
	case NF4CHR:
		 if (!zdr_specdata4 (zdrs, &objp->createtype4_u.devdata))
			 return FALSE;
		break;
	case NF4SOCK:
	case NF4FIFO:
	case NF4DIR:
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_CREATE4args (ZDR *zdrs, CREATE4args *objp)
{
	

	 if (!zdr_createtype4 (zdrs, &objp->objtype))
		 return FALSE;
	 if (!zdr_component4 (zdrs, &objp->objname))
		 return FALSE;
	 if (!zdr_fattr4 (zdrs, &objp->createattrs))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CREATE4resok (ZDR *zdrs, CREATE4resok *objp)
{
	

	 if (!zdr_change_info4 (zdrs, &objp->cinfo))
		 return FALSE;
	 if (!zdr_bitmap4 (zdrs, &objp->attrset))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CREATE4res (ZDR *zdrs, CREATE4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_CREATE4resok (zdrs, &objp->CREATE4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_DELEGPURGE4args (ZDR *zdrs, DELEGPURGE4args *objp)
{
	

	 if (!zdr_clientid4 (zdrs, &objp->clientid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_DELEGPURGE4res (ZDR *zdrs, DELEGPURGE4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_DELEGRETURN4args (ZDR *zdrs, DELEGRETURN4args *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->deleg_stateid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_DELEGRETURN4res (ZDR *zdrs, DELEGRETURN4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_GETATTR4args (ZDR *zdrs, GETATTR4args *objp)
{
	

	 if (!zdr_bitmap4 (zdrs, &objp->attr_request))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_GETATTR4resok (ZDR *zdrs, GETATTR4resok *objp)
{
	

	 if (!zdr_fattr4 (zdrs, &objp->obj_attributes))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_GETATTR4res (ZDR *zdrs, GETATTR4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_GETATTR4resok (zdrs, &objp->GETATTR4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_GETFH4resok (ZDR *zdrs, GETFH4resok *objp)
{
	

	 if (!zdr_nfs_fh4 (zdrs, &objp->object))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_GETFH4res (ZDR *zdrs, GETFH4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_GETFH4resok (zdrs, &objp->GETFH4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_LINK4args (ZDR *zdrs, LINK4args *objp)
{
	

	 if (!zdr_component4 (zdrs, &objp->newname))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LINK4resok (ZDR *zdrs, LINK4resok *objp)
{
	

	 if (!zdr_change_info4 (zdrs, &objp->cinfo))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LINK4res (ZDR *zdrs, LINK4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_LINK4resok (zdrs, &objp->LINK4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_open_to_lock_owner4 (ZDR *zdrs, open_to_lock_owner4 *objp)
{
	

	 if (!zdr_seqid4 (zdrs, &objp->open_seqid))
		 return FALSE;
	 if (!zdr_stateid4 (zdrs, &objp->open_stateid))
		 return FALSE;
	 if (!zdr_seqid4 (zdrs, &objp->lock_seqid))
		 return FALSE;
	 if (!zdr_lock_owner4 (zdrs, &objp->lock_owner))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_exist_lock_owner4 (ZDR *zdrs, exist_lock_owner4 *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->lock_stateid))
		 return FALSE;
	 if (!zdr_seqid4 (zdrs, &objp->lock_seqid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_locker4 (ZDR *zdrs, locker4 *objp)
{
	

	 if (!zdr_bool (zdrs, &objp->new_lock_owner))
		 return FALSE;
	switch (objp->new_lock_owner) {
	case TRUE:
		 if (!zdr_open_to_lock_owner4 (zdrs, &objp->locker4_u.open_owner))
			 return FALSE;
		break;
	case FALSE:
		 if (!zdr_exist_lock_owner4 (zdrs, &objp->locker4_u.lock_owner))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_LOCK4args (ZDR *zdrs, LOCK4args *objp)
{
	

	 if (!zdr_nfs_lock_type4 (zdrs, &objp->locktype))
		 return FALSE;
	 if (!zdr_bool (zdrs, &objp->reclaim))
		 return FALSE;
	 if (!zdr_offset4 (zdrs, &objp->offset))
		 return FALSE;
	 if (!zdr_length4 (zdrs, &objp->length))
		 return FALSE;
	 if (!zdr_locker4 (zdrs, &objp->locker))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LOCK4denied (ZDR *zdrs, LOCK4denied *objp)
{
	

	 if (!zdr_offset4 (zdrs, &objp->offset))
		 return FALSE;
	 if (!zdr_length4 (zdrs, &objp->length))
		 return FALSE;
	 if (!zdr_nfs_lock_type4 (zdrs, &objp->locktype))
		 return FALSE;
	 if (!zdr_lock_owner4 (zdrs, &objp->owner))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LOCK4resok (ZDR *zdrs, LOCK4resok *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->lock_stateid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LOCK4res (ZDR *zdrs, LOCK4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_LOCK4resok (zdrs, &objp->LOCK4res_u.resok4))
			 return FALSE;
		break;
	case NFS4ERR_DENIED:
		 if (!zdr_LOCK4denied (zdrs, &objp->LOCK4res_u.denied))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_LOCKT4args (ZDR *zdrs, LOCKT4args *objp)
{
	

	 if (!zdr_nfs_lock_type4 (zdrs, &objp->locktype))
		 return FALSE;
	 if (!zdr_offset4 (zdrs, &objp->offset))
		 return FALSE;
	 if (!zdr_length4 (zdrs, &objp->length))
		 return FALSE;
	 if (!zdr_lock_owner4 (zdrs, &objp->owner))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LOCKT4res (ZDR *zdrs, LOCKT4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4ERR_DENIED:
		 if (!zdr_LOCK4denied (zdrs, &objp->LOCKT4res_u.denied))
			 return FALSE;
		break;
	case NFS4_OK:
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_LOCKU4args (ZDR *zdrs, LOCKU4args *objp)
{
	

	 if (!zdr_nfs_lock_type4 (zdrs, &objp->locktype))
		 return FALSE;
	 if (!zdr_seqid4 (zdrs, &objp->seqid))
		 return FALSE;
	 if (!zdr_stateid4 (zdrs, &objp->lock_stateid))
		 return FALSE;
	 if (!zdr_offset4 (zdrs, &objp->offset))
		 return FALSE;
	 if (!zdr_length4 (zdrs, &objp->length))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LOCKU4res (ZDR *zdrs, LOCKU4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_stateid4 (zdrs, &objp->LOCKU4res_u.lock_stateid))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_LOOKUP4args (ZDR *zdrs, LOOKUP4args *objp)
{
	

	 if (!zdr_component4 (zdrs, &objp->objname))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LOOKUP4res (ZDR *zdrs, LOOKUP4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_LOOKUPP4res (ZDR *zdrs, LOOKUPP4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_NVERIFY4args (ZDR *zdrs, NVERIFY4args *objp)
{
	

	 if (!zdr_fattr4 (zdrs, &objp->obj_attributes))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_NVERIFY4res (ZDR *zdrs, NVERIFY4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_createmode4 (ZDR *zdrs, createmode4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_createhow4 (ZDR *zdrs, createhow4 *objp)
{
	

	 if (!zdr_createmode4 (zdrs, &objp->mode))
		 return FALSE;
	switch (objp->mode) {
	case UNCHECKED4:
	case GUARDED4:
		 if (!zdr_fattr4 (zdrs, &objp->createhow4_u.createattrs))
			 return FALSE;
		break;
	case EXCLUSIVE4:
		 if (!zdr_verifier4 (zdrs, objp->createhow4_u.createverf))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_opentype4 (ZDR *zdrs, opentype4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_openflag4 (ZDR *zdrs, openflag4 *objp)
{
	

	 if (!zdr_opentype4 (zdrs, &objp->opentype))
		 return FALSE;
	switch (objp->opentype) {
	case OPEN4_CREATE:
		 if (!zdr_createhow4 (zdrs, &objp->openflag4_u.how))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_limit_by4 (ZDR *zdrs, limit_by4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_modified_limit4 (ZDR *zdrs, nfs_modified_limit4 *objp)
{
	

	 if (!zdr_uint32_t (zdrs, &objp->num_blocks))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->bytes_per_block))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_space_limit4 (ZDR *zdrs, nfs_space_limit4 *objp)
{
	

	 if (!zdr_limit_by4 (zdrs, &objp->limitby))
		 return FALSE;
	switch (objp->limitby) {
	case NFS_LIMIT_SIZE:
		 if (!zdr_uint64_t (zdrs, &objp->nfs_space_limit4_u.filesize))
			 return FALSE;
		break;
	case NFS_LIMIT_BLOCKS:
		 if (!zdr_nfs_modified_limit4 (zdrs, &objp->nfs_space_limit4_u.mod_blocks))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_open_delegation_type4 (ZDR *zdrs, open_delegation_type4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_open_claim_type4 (ZDR *zdrs, open_claim_type4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_open_claim_delegate_cur4 (ZDR *zdrs, open_claim_delegate_cur4 *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->delegate_stateid))
		 return FALSE;
	 if (!zdr_component4 (zdrs, &objp->file))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_open_claim4 (ZDR *zdrs, open_claim4 *objp)
{
	

	 if (!zdr_open_claim_type4 (zdrs, &objp->claim))
		 return FALSE;
	switch (objp->claim) {
	case CLAIM_NULL:
		 if (!zdr_component4 (zdrs, &objp->open_claim4_u.file))
			 return FALSE;
		break;
	case CLAIM_PREVIOUS:
		 if (!zdr_open_delegation_type4 (zdrs, &objp->open_claim4_u.delegate_type))
			 return FALSE;
		break;
	case CLAIM_DELEGATE_CUR:
		 if (!zdr_open_claim_delegate_cur4 (zdrs, &objp->open_claim4_u.delegate_cur_info))
			 return FALSE;
		break;
	case CLAIM_DELEGATE_PREV:
		 if (!zdr_component4 (zdrs, &objp->open_claim4_u.file_delegate_prev))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_OPEN4args (ZDR *zdrs, OPEN4args *objp)
{
	

	 if (!zdr_seqid4 (zdrs, &objp->seqid))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->share_access))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->share_deny))
		 return FALSE;
	 if (!zdr_open_owner4 (zdrs, &objp->owner))
		 return FALSE;
	 if (!zdr_openflag4 (zdrs, &objp->openhow))
		 return FALSE;
	 if (!zdr_open_claim4 (zdrs, &objp->claim))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_open_read_delegation4 (ZDR *zdrs, open_read_delegation4 *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->stateid))
		 return FALSE;
	 if (!zdr_bool (zdrs, &objp->recall))
		 return FALSE;
	 if (!zdr_nfsace4 (zdrs, &objp->permissions))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_open_write_delegation4 (ZDR *zdrs, open_write_delegation4 *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->stateid))
		 return FALSE;
	 if (!zdr_bool (zdrs, &objp->recall))
		 return FALSE;
	 if (!zdr_nfs_space_limit4 (zdrs, &objp->space_limit))
		 return FALSE;
	 if (!zdr_nfsace4 (zdrs, &objp->permissions))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_open_delegation4 (ZDR *zdrs, open_delegation4 *objp)
{
	

	 if (!zdr_open_delegation_type4 (zdrs, &objp->delegation_type))
		 return FALSE;
	switch (objp->delegation_type) {
	case OPEN_DELEGATE_NONE:
		break;
	case OPEN_DELEGATE_READ:
		 if (!zdr_open_read_delegation4 (zdrs, &objp->open_delegation4_u.read))
			 return FALSE;
		break;
	case OPEN_DELEGATE_WRITE:
		 if (!zdr_open_write_delegation4 (zdrs, &objp->open_delegation4_u.write))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_OPEN4resok (ZDR *zdrs, OPEN4resok *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->stateid))
		 return FALSE;
	 if (!zdr_change_info4 (zdrs, &objp->cinfo))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->rflags))
		 return FALSE;
	 if (!zdr_bitmap4 (zdrs, &objp->attrset))
		 return FALSE;
	 if (!zdr_open_delegation4 (zdrs, &objp->delegation))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_OPEN4res (ZDR *zdrs, OPEN4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_OPEN4resok (zdrs, &objp->OPEN4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_OPENATTR4args (ZDR *zdrs, OPENATTR4args *objp)
{
	

	 if (!zdr_bool (zdrs, &objp->createdir))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_OPENATTR4res (ZDR *zdrs, OPENATTR4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_OPEN_CONFIRM4args (ZDR *zdrs, OPEN_CONFIRM4args *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->open_stateid))
		 return FALSE;
	 if (!zdr_seqid4 (zdrs, &objp->seqid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_OPEN_CONFIRM4resok (ZDR *zdrs, OPEN_CONFIRM4resok *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->open_stateid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_OPEN_CONFIRM4res (ZDR *zdrs, OPEN_CONFIRM4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_OPEN_CONFIRM4resok (zdrs, &objp->OPEN_CONFIRM4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_OPEN_DOWNGRADE4args (ZDR *zdrs, OPEN_DOWNGRADE4args *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->open_stateid))
		 return FALSE;
	 if (!zdr_seqid4 (zdrs, &objp->seqid))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->share_access))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->share_deny))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_OPEN_DOWNGRADE4resok (ZDR *zdrs, OPEN_DOWNGRADE4resok *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->open_stateid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_OPEN_DOWNGRADE4res (ZDR *zdrs, OPEN_DOWNGRADE4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_OPEN_DOWNGRADE4resok (zdrs, &objp->OPEN_DOWNGRADE4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_PUTFH4args (ZDR *zdrs, PUTFH4args *objp)
{
	

	 if (!zdr_nfs_fh4 (zdrs, &objp->object))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_PUTFH4res (ZDR *zdrs, PUTFH4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_PUTPUBFH4res (ZDR *zdrs, PUTPUBFH4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_PUTROOTFH4res (ZDR *zdrs, PUTROOTFH4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_READ4args (ZDR *zdrs, READ4args *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->stateid))
		 return FALSE;
	 if (!zdr_offset4 (zdrs, &objp->offset))
		 return FALSE;
	 if (!zdr_count4 (zdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_READ4resok (ZDR *zdrs, READ4resok *objp)
{
	

	 if (!zdr_bool (zdrs, &objp->eof))
		 return FALSE;
	 if (!zdr_bytes (zdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_READ4res (ZDR *zdrs, READ4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_READ4resok (zdrs, &objp->READ4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_READDIR4args (ZDR *zdrs, READDIR4args *objp)
{
	

	 if (!zdr_nfs_cookie4 (zdrs, &objp->cookie))
		 return FALSE;
	 if (!zdr_verifier4 (zdrs, objp->cookieverf))
		 return FALSE;
	 if (!zdr_count4 (zdrs, &objp->dircount))
		 return FALSE;
	 if (!zdr_count4 (zdrs, &objp->maxcount))
		 return FALSE;
	 if (!zdr_bitmap4 (zdrs, &objp->attr_request))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_entry4 (ZDR *zdrs, entry4 *objp)
{
	

	 if (!zdr_nfs_cookie4 (zdrs, &objp->cookie))
		 return FALSE;
	 if (!zdr_component4 (zdrs, &objp->name))
		 return FALSE;
	 if (!zdr_fattr4 (zdrs, &objp->attrs))
		 return FALSE;
	 if (!zdr_pointer (zdrs, (char **)&objp->nextentry, sizeof (entry4), (zdrproc_t) zdr_entry4))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_dirlist4 (ZDR *zdrs, dirlist4 *objp)
{
	

	 if (!zdr_pointer (zdrs, (char **)&objp->entries, sizeof (entry4), (zdrproc_t) zdr_entry4))
		 return FALSE;
	 if (!zdr_bool (zdrs, &objp->eof))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_READDIR4resok (ZDR *zdrs, READDIR4resok *objp)
{
	

	 if (!zdr_verifier4 (zdrs, objp->cookieverf))
		 return FALSE;
	 if (!zdr_dirlist4 (zdrs, &objp->reply))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_READDIR4res (ZDR *zdrs, READDIR4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_READDIR4resok (zdrs, &objp->READDIR4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_READLINK4resok (ZDR *zdrs, READLINK4resok *objp)
{
	

	 if (!zdr_linktext4 (zdrs, &objp->link))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_READLINK4res (ZDR *zdrs, READLINK4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_READLINK4resok (zdrs, &objp->READLINK4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_REMOVE4args (ZDR *zdrs, REMOVE4args *objp)
{
	

	 if (!zdr_component4 (zdrs, &objp->target))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_REMOVE4resok (ZDR *zdrs, REMOVE4resok *objp)
{
	

	 if (!zdr_change_info4 (zdrs, &objp->cinfo))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_REMOVE4res (ZDR *zdrs, REMOVE4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_REMOVE4resok (zdrs, &objp->REMOVE4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_RENAME4args (ZDR *zdrs, RENAME4args *objp)
{
	

	 if (!zdr_component4 (zdrs, &objp->oldname))
		 return FALSE;
	 if (!zdr_component4 (zdrs, &objp->newname))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_RENAME4resok (ZDR *zdrs, RENAME4resok *objp)
{
	

	 if (!zdr_change_info4 (zdrs, &objp->source_cinfo))
		 return FALSE;
	 if (!zdr_change_info4 (zdrs, &objp->target_cinfo))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_RENAME4res (ZDR *zdrs, RENAME4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_RENAME4resok (zdrs, &objp->RENAME4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_RENEW4args (ZDR *zdrs, RENEW4args *objp)
{
	

	 if (!zdr_clientid4 (zdrs, &objp->clientid))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_RENEW4res (ZDR *zdrs, RENEW4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_RESTOREFH4res (ZDR *zdrs, RESTOREFH4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_SAVEFH4res (ZDR *zdrs, SAVEFH4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_SETATTR4args (ZDR *zdrs, SETATTR4args *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->stateid))
		 return FALSE;
	 if (!zdr_fattr4 (zdrs, &objp->obj_attributes))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_SETATTR4res (ZDR *zdrs, SETATTR4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	 if (!zdr_bitmap4 (zdrs, &objp->attrsset))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_SETCLIENTID4args (ZDR *zdrs, SETCLIENTID4args *objp)
{
	

	 if (!zdr_nfs_client_id4 (zdrs, &objp->client))
		 return FALSE;
	 if (!zdr_cb_client4 (zdrs, &objp->callback))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->callback_ident))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_SETCLIENTID4resok (ZDR *zdrs, SETCLIENTID4resok *objp)
{
	

	 if (!zdr_clientid4 (zdrs, &objp->clientid))
		 return FALSE;
	 if (!zdr_verifier4 (zdrs, objp->setclientid_confirm))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_SETCLIENTID4res (ZDR *zdrs, SETCLIENTID4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_SETCLIENTID4resok (zdrs, &objp->SETCLIENTID4res_u.resok4))
			 return FALSE;
		break;
	case NFS4ERR_CLID_INUSE:
		 if (!zdr_clientaddr4 (zdrs, &objp->SETCLIENTID4res_u.client_using))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_SETCLIENTID_CONFIRM4args (ZDR *zdrs, SETCLIENTID_CONFIRM4args *objp)
{
	

	 if (!zdr_clientid4 (zdrs, &objp->clientid))
		 return FALSE;
	 if (!zdr_verifier4 (zdrs, objp->setclientid_confirm))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_SETCLIENTID_CONFIRM4res (ZDR *zdrs, SETCLIENTID_CONFIRM4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_VERIFY4args (ZDR *zdrs, VERIFY4args *objp)
{
	

	 if (!zdr_fattr4 (zdrs, &objp->obj_attributes))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_VERIFY4res (ZDR *zdrs, VERIFY4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_stable_how4 (ZDR *zdrs, stable_how4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_WRITE4args (ZDR *zdrs, WRITE4args *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->stateid))
		 return FALSE;
	 if (!zdr_offset4 (zdrs, &objp->offset))
		 return FALSE;
	 if (!zdr_stable_how4 (zdrs, &objp->stable))
		 return FALSE;
	 if (!zdr_bytes (zdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_WRITE4resok (ZDR *zdrs, WRITE4resok *objp)
{
	

	 if (!zdr_count4 (zdrs, &objp->count))
		 return FALSE;
	 if (!zdr_stable_how4 (zdrs, &objp->committed))
		 return FALSE;
	 if (!zdr_verifier4 (zdrs, objp->writeverf))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_WRITE4res (ZDR *zdrs, WRITE4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_WRITE4resok (zdrs, &objp->WRITE4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_RELEASE_LOCKOWNER4args (ZDR *zdrs, RELEASE_LOCKOWNER4args *objp)
{
	

	 if (!zdr_lock_owner4 (zdrs, &objp->lock_owner))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_RELEASE_LOCKOWNER4res (ZDR *zdrs, RELEASE_LOCKOWNER4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_ILLEGAL4res (ZDR *zdrs, ILLEGAL4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_opnum4 (ZDR *zdrs, nfs_opnum4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_argop4 (ZDR *zdrs, nfs_argop4 *objp)
{
	

	 if (!zdr_nfs_opnum4 (zdrs, &objp->argop))
		 return FALSE;
	switch (objp->argop) {
	case OP_ACCESS:
		 if (!zdr_ACCESS4args (zdrs, &objp->nfs_argop4_u.opaccess))
			 return FALSE;
		break;
	case OP_CLOSE:
		 if (!zdr_CLOSE4args (zdrs, &objp->nfs_argop4_u.opclose))
			 return FALSE;
		break;
	case OP_COMMIT:
		 if (!zdr_COMMIT4args (zdrs, &objp->nfs_argop4_u.opcommit))
			 return FALSE;
		break;
	case OP_CREATE:
		 if (!zdr_CREATE4args (zdrs, &objp->nfs_argop4_u.opcreate))
			 return FALSE;
		break;
	case OP_DELEGPURGE:
		 if (!zdr_DELEGPURGE4args (zdrs, &objp->nfs_argop4_u.opdelegpurge))
			 return FALSE;
		break;
	case OP_DELEGRETURN:
		 if (!zdr_DELEGRETURN4args (zdrs, &objp->nfs_argop4_u.opdelegreturn))
			 return FALSE;
		break;
	case OP_GETATTR:
		 if (!zdr_GETATTR4args (zdrs, &objp->nfs_argop4_u.opgetattr))
			 return FALSE;
		break;
	case OP_GETFH:
		break;
	case OP_LINK:
		 if (!zdr_LINK4args (zdrs, &objp->nfs_argop4_u.oplink))
			 return FALSE;
		break;
	case OP_LOCK:
		 if (!zdr_LOCK4args (zdrs, &objp->nfs_argop4_u.oplock))
			 return FALSE;
		break;
	case OP_LOCKT:
		 if (!zdr_LOCKT4args (zdrs, &objp->nfs_argop4_u.oplockt))
			 return FALSE;
		break;
	case OP_LOCKU:
		 if (!zdr_LOCKU4args (zdrs, &objp->nfs_argop4_u.oplocku))
			 return FALSE;
		break;
	case OP_LOOKUP:
		 if (!zdr_LOOKUP4args (zdrs, &objp->nfs_argop4_u.oplookup))
			 return FALSE;
		break;
	case OP_LOOKUPP:
		break;
	case OP_NVERIFY:
		 if (!zdr_NVERIFY4args (zdrs, &objp->nfs_argop4_u.opnverify))
			 return FALSE;
		break;
	case OP_OPEN:
		 if (!zdr_OPEN4args (zdrs, &objp->nfs_argop4_u.opopen))
			 return FALSE;
		break;
	case OP_OPENATTR:
		 if (!zdr_OPENATTR4args (zdrs, &objp->nfs_argop4_u.opopenattr))
			 return FALSE;
		break;
	case OP_OPEN_CONFIRM:
		 if (!zdr_OPEN_CONFIRM4args (zdrs, &objp->nfs_argop4_u.opopen_confirm))
			 return FALSE;
		break;
	case OP_OPEN_DOWNGRADE:
		 if (!zdr_OPEN_DOWNGRADE4args (zdrs, &objp->nfs_argop4_u.opopen_downgrade))
			 return FALSE;
		break;
	case OP_PUTFH:
		 if (!zdr_PUTFH4args (zdrs, &objp->nfs_argop4_u.opputfh))
			 return FALSE;
		break;
	case OP_PUTPUBFH:
		break;
	case OP_PUTROOTFH:
		break;
	case OP_READ:
		 if (!zdr_READ4args (zdrs, &objp->nfs_argop4_u.opread))
			 return FALSE;
		break;
	case OP_READDIR:
		 if (!zdr_READDIR4args (zdrs, &objp->nfs_argop4_u.opreaddir))
			 return FALSE;
		break;
	case OP_READLINK:
		break;
	case OP_REMOVE:
		 if (!zdr_REMOVE4args (zdrs, &objp->nfs_argop4_u.opremove))
			 return FALSE;
		break;
	case OP_RENAME:
		 if (!zdr_RENAME4args (zdrs, &objp->nfs_argop4_u.oprename))
			 return FALSE;
		break;
	case OP_RENEW:
		 if (!zdr_RENEW4args (zdrs, &objp->nfs_argop4_u.oprenew))
			 return FALSE;
		break;
	case OP_RESTOREFH:
		break;
	case OP_SAVEFH:
		break;
	case OP_SETATTR:
		 if (!zdr_SETATTR4args (zdrs, &objp->nfs_argop4_u.opsetattr))
			 return FALSE;
		break;
	case OP_SETCLIENTID:
		 if (!zdr_SETCLIENTID4args (zdrs, &objp->nfs_argop4_u.opsetclientid))
			 return FALSE;
		break;
	case OP_SETCLIENTID_CONFIRM:
		 if (!zdr_SETCLIENTID_CONFIRM4args (zdrs, &objp->nfs_argop4_u.opsetclientid_confirm))
			 return FALSE;
		break;
	case OP_VERIFY:
		 if (!zdr_VERIFY4args (zdrs, &objp->nfs_argop4_u.opverify))
			 return FALSE;
		break;
	case OP_WRITE:
		 if (!zdr_WRITE4args (zdrs, &objp->nfs_argop4_u.opwrite))
			 return FALSE;
		break;
	case OP_RELEASE_LOCKOWNER:
		 if (!zdr_RELEASE_LOCKOWNER4args (zdrs, &objp->nfs_argop4_u.oprelease_lockowner))
			 return FALSE;
		break;
	case OP_ILLEGAL:
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_nfs_resop4 (ZDR *zdrs, nfs_resop4 *objp)
{
	

	 if (!zdr_nfs_opnum4 (zdrs, &objp->resop))
		 return FALSE;
	switch (objp->resop) {
	case OP_ACCESS:
		 if (!zdr_ACCESS4res (zdrs, &objp->nfs_resop4_u.opaccess))
			 return FALSE;
		break;
	case OP_CLOSE:
		 if (!zdr_CLOSE4res (zdrs, &objp->nfs_resop4_u.opclose))
			 return FALSE;
		break;
	case OP_COMMIT:
		 if (!zdr_COMMIT4res (zdrs, &objp->nfs_resop4_u.opcommit))
			 return FALSE;
		break;
	case OP_CREATE:
		 if (!zdr_CREATE4res (zdrs, &objp->nfs_resop4_u.opcreate))
			 return FALSE;
		break;
	case OP_DELEGPURGE:
		 if (!zdr_DELEGPURGE4res (zdrs, &objp->nfs_resop4_u.opdelegpurge))
			 return FALSE;
		break;
	case OP_DELEGRETURN:
		 if (!zdr_DELEGRETURN4res (zdrs, &objp->nfs_resop4_u.opdelegreturn))
			 return FALSE;
		break;
	case OP_GETATTR:
		 if (!zdr_GETATTR4res (zdrs, &objp->nfs_resop4_u.opgetattr))
			 return FALSE;
		break;
	case OP_GETFH:
		 if (!zdr_GETFH4res (zdrs, &objp->nfs_resop4_u.opgetfh))
			 return FALSE;
		break;
	case OP_LINK:
		 if (!zdr_LINK4res (zdrs, &objp->nfs_resop4_u.oplink))
			 return FALSE;
		break;
	case OP_LOCK:
		 if (!zdr_LOCK4res (zdrs, &objp->nfs_resop4_u.oplock))
			 return FALSE;
		break;
	case OP_LOCKT:
		 if (!zdr_LOCKT4res (zdrs, &objp->nfs_resop4_u.oplockt))
			 return FALSE;
		break;
	case OP_LOCKU:
		 if (!zdr_LOCKU4res (zdrs, &objp->nfs_resop4_u.oplocku))
			 return FALSE;
		break;
	case OP_LOOKUP:
		 if (!zdr_LOOKUP4res (zdrs, &objp->nfs_resop4_u.oplookup))
			 return FALSE;
		break;
	case OP_LOOKUPP:
		 if (!zdr_LOOKUPP4res (zdrs, &objp->nfs_resop4_u.oplookupp))
			 return FALSE;
		break;
	case OP_NVERIFY:
		 if (!zdr_NVERIFY4res (zdrs, &objp->nfs_resop4_u.opnverify))
			 return FALSE;
		break;
	case OP_OPEN:
		 if (!zdr_OPEN4res (zdrs, &objp->nfs_resop4_u.opopen))
			 return FALSE;
		break;
	case OP_OPENATTR:
		 if (!zdr_OPENATTR4res (zdrs, &objp->nfs_resop4_u.opopenattr))
			 return FALSE;
		break;
	case OP_OPEN_CONFIRM:
		 if (!zdr_OPEN_CONFIRM4res (zdrs, &objp->nfs_resop4_u.opopen_confirm))
			 return FALSE;
		break;
	case OP_OPEN_DOWNGRADE:
		 if (!zdr_OPEN_DOWNGRADE4res (zdrs, &objp->nfs_resop4_u.opopen_downgrade))
			 return FALSE;
		break;
	case OP_PUTFH:
		 if (!zdr_PUTFH4res (zdrs, &objp->nfs_resop4_u.opputfh))
			 return FALSE;
		break;
	case OP_PUTPUBFH:
		 if (!zdr_PUTPUBFH4res (zdrs, &objp->nfs_resop4_u.opputpubfh))
			 return FALSE;
		break;
	case OP_PUTROOTFH:
		 if (!zdr_PUTROOTFH4res (zdrs, &objp->nfs_resop4_u.opputrootfh))
			 return FALSE;
		break;
	case OP_READ:
		 if (!zdr_READ4res (zdrs, &objp->nfs_resop4_u.opread))
			 return FALSE;
		break;
	case OP_READDIR:
		 if (!zdr_READDIR4res (zdrs, &objp->nfs_resop4_u.opreaddir))
			 return FALSE;
		break;
	case OP_READLINK:
		 if (!zdr_READLINK4res (zdrs, &objp->nfs_resop4_u.opreadlink))
			 return FALSE;
		break;
	case OP_REMOVE:
		 if (!zdr_REMOVE4res (zdrs, &objp->nfs_resop4_u.opremove))
			 return FALSE;
		break;
	case OP_RENAME:
		 if (!zdr_RENAME4res (zdrs, &objp->nfs_resop4_u.oprename))
			 return FALSE;
		break;
	case OP_RENEW:
		 if (!zdr_RENEW4res (zdrs, &objp->nfs_resop4_u.oprenew))
			 return FALSE;
		break;
	case OP_RESTOREFH:
		 if (!zdr_RESTOREFH4res (zdrs, &objp->nfs_resop4_u.oprestorefh))
			 return FALSE;
		break;
	case OP_SAVEFH:
		 if (!zdr_SAVEFH4res (zdrs, &objp->nfs_resop4_u.opsavefh))
			 return FALSE;
		break;
	case OP_SETATTR:
		 if (!zdr_SETATTR4res (zdrs, &objp->nfs_resop4_u.opsetattr))
			 return FALSE;
		break;
	case OP_SETCLIENTID:
		 if (!zdr_SETCLIENTID4res (zdrs, &objp->nfs_resop4_u.opsetclientid))
			 return FALSE;
		break;
	case OP_SETCLIENTID_CONFIRM:
		 if (!zdr_SETCLIENTID_CONFIRM4res (zdrs, &objp->nfs_resop4_u.opsetclientid_confirm))
			 return FALSE;
		break;
	case OP_VERIFY:
		 if (!zdr_VERIFY4res (zdrs, &objp->nfs_resop4_u.opverify))
			 return FALSE;
		break;
	case OP_WRITE:
		 if (!zdr_WRITE4res (zdrs, &objp->nfs_resop4_u.opwrite))
			 return FALSE;
		break;
	case OP_RELEASE_LOCKOWNER:
		 if (!zdr_RELEASE_LOCKOWNER4res (zdrs, &objp->nfs_resop4_u.oprelease_lockowner))
			 return FALSE;
		break;
	case OP_ILLEGAL:
		 if (!zdr_ILLEGAL4res (zdrs, &objp->nfs_resop4_u.opillegal))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_COMPOUND4args (ZDR *zdrs, COMPOUND4args *objp)
{
	

	 if (!zdr_utf8str_cs (zdrs, &objp->tag))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->minorversion))
		 return FALSE;
	 if (!zdr_array (zdrs, (char **)&objp->argarray.argarray_val, (u_int *) &objp->argarray.argarray_len, ~0,
		sizeof (nfs_argop4), (zdrproc_t) zdr_nfs_argop4))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_COMPOUND4res (ZDR *zdrs, COMPOUND4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	 if (!zdr_utf8str_cs (zdrs, &objp->tag))
		 return FALSE;
	 if (!zdr_array (zdrs, (char **)&objp->resarray.resarray_val, (u_int *) &objp->resarray.resarray_len, ~0,
		sizeof (nfs_resop4), (zdrproc_t) zdr_nfs_resop4))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CB_GETATTR4args (ZDR *zdrs, CB_GETATTR4args *objp)
{
	

	 if (!zdr_nfs_fh4 (zdrs, &objp->fh))
		 return FALSE;
	 if (!zdr_bitmap4 (zdrs, &objp->attr_request))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CB_GETATTR4resok (ZDR *zdrs, CB_GETATTR4resok *objp)
{
	

	 if (!zdr_fattr4 (zdrs, &objp->obj_attributes))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CB_GETATTR4res (ZDR *zdrs, CB_GETATTR4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case NFS4_OK:
		 if (!zdr_CB_GETATTR4resok (zdrs, &objp->CB_GETATTR4res_u.resok4))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

uint32_t
zdr_CB_RECALL4args (ZDR *zdrs, CB_RECALL4args *objp)
{
	

	 if (!zdr_stateid4 (zdrs, &objp->stateid))
		 return FALSE;
	 if (!zdr_bool (zdrs, &objp->truncate))
		 return FALSE;
	 if (!zdr_nfs_fh4 (zdrs, &objp->fh))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CB_RECALL4res (ZDR *zdrs, CB_RECALL4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CB_ILLEGAL4res (ZDR *zdrs, CB_ILLEGAL4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_cb_opnum4 (ZDR *zdrs, nfs_cb_opnum4 *objp)
{
	

	 if (!zdr_enum (zdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_nfs_cb_argop4 (ZDR *zdrs, nfs_cb_argop4 *objp)
{
	

	 if (!zdr_u_int (zdrs, &objp->argop))
		 return FALSE;
	switch (objp->argop) {
	case OP_CB_GETATTR:
		 if (!zdr_CB_GETATTR4args (zdrs, &objp->nfs_cb_argop4_u.opcbgetattr))
			 return FALSE;
		break;
	case OP_CB_RECALL:
		 if (!zdr_CB_RECALL4args (zdrs, &objp->nfs_cb_argop4_u.opcbrecall))
			 return FALSE;
		break;
	case OP_CB_ILLEGAL:
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_nfs_cb_resop4 (ZDR *zdrs, nfs_cb_resop4 *objp)
{
	

	 if (!zdr_u_int (zdrs, &objp->resop))
		 return FALSE;
	switch (objp->resop) {
	case OP_CB_GETATTR:
		 if (!zdr_CB_GETATTR4res (zdrs, &objp->nfs_cb_resop4_u.opcbgetattr))
			 return FALSE;
		break;
	case OP_CB_RECALL:
		 if (!zdr_CB_RECALL4res (zdrs, &objp->nfs_cb_resop4_u.opcbrecall))
			 return FALSE;
		break;
	case OP_CB_ILLEGAL:
		 if (!zdr_CB_ILLEGAL4res (zdrs, &objp->nfs_cb_resop4_u.opcbillegal))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

uint32_t
zdr_CB_COMPOUND4args (ZDR *zdrs, CB_COMPOUND4args *objp)
{
	

	 if (!zdr_utf8str_cs (zdrs, &objp->tag))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->minorversion))
		 return FALSE;
	 if (!zdr_uint32_t (zdrs, &objp->callback_ident))
		 return FALSE;
	 if (!zdr_array (zdrs, (char **)&objp->argarray.argarray_val, (u_int *) &objp->argarray.argarray_len, ~0,
		sizeof (nfs_cb_argop4), (zdrproc_t) zdr_nfs_cb_argop4))
		 return FALSE;
	return TRUE;
}

uint32_t
zdr_CB_COMPOUND4res (ZDR *zdrs, CB_COMPOUND4res *objp)
{
	

	 if (!zdr_nfsstat4 (zdrs, &objp->status))
		 return FALSE;
	 if (!zdr_utf8str_cs (zdrs, &objp->tag))
		 return FALSE;
	 if (!zdr_array (zdrs, (char **)&objp->resarray.resarray_val, (u_int *) &objp->resarray.resarray_len, ~0,
		sizeof (nfs_cb_resop4), (zdrproc_t) zdr_nfs_cb_resop4))
		 return FALSE;
	return TRUE;
}
